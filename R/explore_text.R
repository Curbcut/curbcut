#' Generate text for the given variables and region
#'
#' This function dispatches to the appropriate text-generating function based on
#' the type of `vars` and returns the resulting text.
#'
#' @param vars <`character`> A list containing the variable names for which the
#' text needs to be generated. Usually the output of \code{\link{vars_build}}.
#' @param region <`character`> String specifying the name of the region.
#' Usually equivalent of `r$region()`.
#' @param select_id A string indicating the ID of the currently selected region
#' (if any). Usually `r[[id]]$select_id()`
#' @param df <`character`> The combination of the region under study and the
#' scale at which the user is on, e.g. `CMA_CSD`. The output of
#' \code{\link{update_df}}.
#' @param data <`data.frame`> A data frame containing the variables and
#' observations to be compared. The data frame must have columns named var_left
#' and ID. The output of \code{\link{data_get}}.
#' @param scales_as_DA <`character vector`> A character vector of `scales`
#' that should be handled as a "DA" scale, e.g. `building` and `street`. By default,
#' their colour will be the one of their DA.
#' @param lang <`character`> A string indicating the language in which to
#' translates the variable. Defaults to NULL. Usually is `r$lang()`.
#' @param ... Additional arguments passed to the dispatched function.
#'
#' @return The resulting text.
#' @export
explore_text <- function(vars, region, select_id, df, data, scales_as_DA,
                         lang, ...) {
  UseMethod("explore_text", vars)
}


# Q5 ----------------------------------------------------------------------

#' @rdname explore_text
#' @export
explore_text.q5 <- function(vars, region, select_id, df, data,
                            scales_as_DA = c("building", "street"),
                            lang = NULL, ...) {
  # Detect if we should switch the scale for DAs in the case the `df` is part
  # of the `scales_as_DA` argument.
  switch_DA <- is_scale_df(scales_as_DA, df)

  # Adjust the selected ID in the case where the selection is not in `data`
  if (!switch_DA && !select_id %in% data$ID) select_id <- NA

  # Grab the shared info
  context <- explore_context(
    region = region, select_id = select_id, df = df,
    switch_DA = switch_DA
  )

  # The context might have used a scale in the `scales_as_DA` argument, and
  # the select_id needs to be switched to that of the dissemination area.
  if ("select_id" %in% names(context)) select_id <- context$select_id

  # Grab the value string
  value_string <- explore_text_values_q5(
    var = vars$var_left, region = region,
    select_id = select_id, data = data,
    df = df
  )

  # Put it all together
  out <- sprintf("<p>%s, %s.", s_sentence(context$p_start), value_string$text)

  # Add the second paragraph if there is a selection
  if (!is.na(select_id) && !value_string$na) {
    # Add header
    out <- sprintf("<p><b>%s</b>%s", context$heading, out)

    # Get the information on how the selection compares
    relat <- explore_text_selection_comparison(
      var = vars$var_left, data = data,
      select_id = select_id
    )

    # Make the first sentence of the paragraph
    first_step <- sprintf(
      "This is %s for %s", relat$rank_chr,
      context$to_compare_determ
    )

    # Grab the explanation and capitalize the first letter
    exp <- var_get_info(vars$var_left, what = "explanation") |>
      s_sentence()

    # Plug the right elements for the final sentence
    second_step <- sprintf(
      "%s %s is higher than %s of other %s %s", exp,
      context$p_start, relat$higher_than, context$scale_plur,
      context$to_compare_short
    )

    # Bind it all
    out <- sprintf("%s<p>%s. %s.", out, first_step, second_step)
  }

  # Append date
  date <- var_get_time(vars$var_left)
  if (!is.na(date)) {
    out <- sprintf("%s <i>(Data from %s.)</i>", out, date)
  }

  # Return the text
  return(out)
}

#' Generate text for the given variables and region - q5 version
#'
#' This function generates text for the given variables and region using the
#' Q5 version. It dispatches to the appropriate text-generating function based on
#' the variable type and returns the resulting text.
#'
#' @param var <`character`> The variable name for which the text needs to be
#' generated. Usually `vars$var_left`
#' @param region <`character`> Character string specifying the name of the region.
#' Usually equivalent of `r$region()`.
#' @param ... Additional arguments passed to the dispatched function.
#'
#' @return The resulting text.
#' @export
explore_text_values_q5 <- function(var, region, ...) {
  UseMethod("explore_text_values_q5", var)
}

#' Generate text for the given variables and region - q5 version using percentage
#'
#' This function generates text for the given variables and region using the
#' q5 version and percentage. It returns the resulting text.
#'
#' @param var <`character`> The variable name for which the text needs to be
#' generated. Usually `vars$var_left`
#' @param region <`character`> Character string specifying the name of the region.
#' Usually equivalent of `r$region()`.
#' @param data <`data.frame`> The output of \code{\link{data_get}}.
#' @param df <`character`>The combination of the region under study
#' and the scale at which the user is on, e.g. `CMA_CSD`. The output of
#' \code{\link{update_df}}.
#' @param select_id <`character`> the current selected ID, usually
#' `r[[id]]$select_id()`.
#' @param col <`character`> Which column of `data` should be selected to grab the
#' value information. Defaults to `var_left`, but could also be `var_right` or
#' `var_left_1` in delta.
#' @param ... Additional arguments passed to the function.
#'
#' @return The resulting text.
#' @export
explore_text_values_q5.pct <- function(var, region, data, df, select_id,
                                       col = "var_left", ...) {
  # Grab the parent variable
  parent_string <- explore_text_parent_title(var)

  # Grab the q5 explanation
  exp <- var_get_info(var = var, what = "exp_q5")

  # Grab the region values
  region_values <- explore_text_region_val_df(
    var = var,
    region = region,
    data = data,
    df = df,
    select_id = select_id,
    col = col
  )

  # NA message
  if (is.na(region_values$val)) {
    exp <- var_get_info(var = var, what = "explanation")
    out <- sprintf("we currently don't have information regarding %s", exp)
    return(list(
      text = out,
      na = TRUE
    ))
  }

  # Make the region values as characters
  pct_string <- convert_unit.pct(x = region_values$val, decimal = 1)
  count_string <- convert_unit(x = region_values$count, decimal = 1)

  # Build the return
  out <- sprintf("%s %s (%s) %s", count_string, parent_string, pct_string, exp)

  # Return
  return(list(
    text = out,
    na = FALSE
  ))
}

#' Generate text for the given variables and region - q5 version using dollar
#'
#' This function generates text for the given variables and region using the
#' q5 version and dollar. It returns the resulting text.
#'
#' @param var <`character`> The variable name for which the text needs to be
#' generated. Usually `vars$var_left`
#' @param region <`character`> Character string specifying the name of the region.
#' Usually equivalent of `r$region()`.
#' @param data <`data.frame`> The output of \code{\link{data_get}}.
#' @param select_id <`character`> the current selected ID, usually
#' `r[[id]]$select_id()`.
#' @param col <`character`> Which column of `data` should be selected to grab the
#' value information. Defaults to `var_left`, but could also be `var_right` or
#' `var_left_1` in delta.
#' @param ... Additional arguments passed to the function.
#'
#' @return The resulting text.
#' @export
explore_text_values_q5.dollar <- function(var, region, data, select_id,
                                          col = "var_left", ...) {
  # Grab the region values
  region_values <- explore_text_region_val_df(
    var = var,
    region = region,
    data = data,
    select_id = select_id,
    col = col
  )

  # NA message
  if (is.na(region_values$val)) {
    exp <- var_get_info(var = var, what = "explanation")
    out <- sprintf("we currently don't have information regarding %s", exp)
    return(list(
      text = out,
      na = TRUE
    ))
  }

  dollar_string <- convert_unit.dollar(x = region_values$val, compact = FALSE)

  # Grab the explanation
  exp <- var_get_info(var = var, what = "exp_q5")

  # Build the return
  out <- sprintf("%s %s", exp, dollar_string)

  # Return
  return(list(
    text = out,
    na = FALSE
  ))
}

#' Generate text for the given variables and region - Q5 version using indices
#'
#' This function generates text for the given variables and region using the
#' q5 version and indices. It returns the resulting text.
#'
#' @param var <`character`> The variable name for which the text needs to be
#' generated. Usually `vars$var_left`
#' @param region <`character`> Character string specifying the name of the region.
#' Usually equivalent of `r$region()`.
#' @param data <`data.frame`> The output of \code{\link{data_get}}.
#' @param df <`character`>The combination of the region under study
#' and the scale at which the user is on, e.g. `CMA_CSD`. The output of
#' \code{\link{update_df}}.
#' @param select_id <`character`> the current selected ID, usually
#' `r[[id]]$select_id()`.
#' @param col <`character`> Which column of `data` should be selected to grab the
#' value information. Defaults to `var_left`, but could also be `var_right` or
#' `var_left_1` in delta.
#' @param ... Additional arguments passed to the function.
#'
#' @return The resulting text.
#' @export
explore_text_values_q5.ind <- function(var, region, select_id, data, df,
                                       col = "var_left", ...) {
  # Grab the parent variable
  parent_string <- explore_text_parent_title(var)

  # Grab the region values
  region_values <- explore_text_region_val_df(
    var = var,
    region = region,
    select_id = select_id,
    data = data,
    df = df,
    col = col
  )

  # NA message
  if (is.na(region_values$val)) {
    exp <- var_get_info(var = var, what = "explanation")
    out <- sprintf("we currently don't have information regarding %s", exp)
    return(list(
      text = out,
      na = TRUE
    ))
  }

  # If there is no selection
  if (is.na(select_id)) {
    # Construct the region values
    pct_string <- convert_unit.pct(x = region_values$val, decimal = 1)
    count_string <- convert_unit(x = region_values$count, decimal = 1)

    # Grab the explanation
    exp_q5 <- var_get_info(var = var, what = "exp_q5")

    # Sub the placeholder for the two last brackets
    breaks <- var_get_info(var = var, what = "breaks_q5")[[1]]
    breaks <- breaks[grepl(paste0("^", region, "_"), breaks$df), ]
    two_last_ranks <- tolower(breaks$rank_name[breaks$rank > 3])[1:2]
    # If the two last brackets is recognized as the default, write a particular string
    exp <- if (identical(two_last_ranks, c("above average", "high"))) {
      gsub("_X_", "a higher-than-average", exp_q5)
    } else {
      gsub("_X_", sprintf(
        "`%s` to `%s`", two_last_ranks[[1]],
        two_last_ranks[[2]]
      ), exp_q5)
    }

    # Build the return
    out <- sprintf("%s %s (%s) %s", count_string, parent_string, pct_string, exp)

    # Return
    return(list(
      text = out,
      na = TRUE
    ))
  }

  # If there is a selection
  exp <- var_get_info(var = var, what = "explanation")

  # Build the return
  out <- sprintf("%s is %s", exp, region_values$val)

  # Return
  return(list(
    text = out,
    na = FALSE
  ))
}


# BIVAR -------------------------------------------------------------------

#' @rdname explore_text
#' @export
explore_text.bivar <- function(vars, region, select_id, df, data,
                               scales_as_DA = c("building", "street"),
                               lang = NULL, ...) {

  # Append date function helper
  append_date <- \(out) {
    date_1 <- var_get_time(vars$var_left)
    date_2 <- var_get_time(vars$var_right)
    date <- if (is.na(date_1) & is.na(date_2)) {
      NA
    } else if (is.na(date_1) & !is.na(date_2)) {
      date_2
    } else if (!is.na(date_1) & is.na(date_2)) {
      date_1
    } else if (date_1 == date_2) {
      date_1
    } else {
      sprintf("%s and %s", date_1, date_2)
    }
    if (!is.na(date)) {
      sprintf("%s <i>(Data from %s.)</i>", out, date)
    }
  }

  # Detect if we should switch the scale for DAs in the case the `df` is part
  # of the `scales_as_DA` argument.
  switch_DA <- is_scale_df(scales_as_DA, df)

  # Adjust the selected ID in the case where the selection is not in `data`
  if (!switch_DA && !select_id %in% data$ID) select_id <- NA

  # Grab the shared info
  context <- explore_context(
    region = region, select_id = select_id, df = df,
    switch_DA = switch_DA
  )

  # The context might have used a scale in the `scales_as_DA` argument, and
  # the select_id needs to be switched to that of the dissemination area.
  if ("select_id" %in% names(context)) select_id <- context$select_id

  # If there is a selection, return a completely diferent text
  if (!is.na(select_id)) {

    # Grab the value string
    value_string_left <- explore_text_values_q5(
      var = vars$var_left, region = region,
      select_id = select_id, data = data,
      df = df
    )

    # Grab the value string
    value_string_right <- explore_text_values_q5(
      var = vars$var_right, region = region,
      select_id = select_id, data = data,
      df = df,
      col = "var_right"
    )

    # If one of the value is NA, return that there is a missing value
    if (value_string_left$na) {
      return(sprintf("<p>%s, %s.", s_sentence(context$p_start),
                     value_string_left$text))
    }
    if (value_string_right$na) {
      return(sprintf("<p>%s, %s.", s_sentence(context$p_start),
                     value_string_right$text))
    }

    # Start with the header
    out <- sprintf("<p><b>%s</b>", context$heading)

    out <- sprintf("%s<p>%s, %s and %s.", out, s_sentence(context$p_start),
                   value_string_left$text, value_string_right$text)

    # Grab the two texts for var_left and var_right
    compare_texts <- lapply(vars, \(var) {

      col <- if (var == vars$var_left) "var_left" else "var_left"

      # Get the information on how the selection compares
      relat <- explore_text_selection_comparison(
        var = var, data = data,
        select_id = select_id,
        col = col
      )

      # Grab the explanation
      exp <- var_get_info(var, what = "explanation")

      # Plug the right elements for the final sentence
      first_step_1 <- if (var == vars$var_left) {
        sprintf("%s %s", exp, context$p_start)
      } else {
        exp
      }
      first_step <- sprintf(
        "%s is higher than %s of other %s", first_step_1, relat$higher_than,
        context$scale_plur
      )

      # Make the second step of the sentence
      second_step <- sprintf(
        "which is %s for %s", relat$rank_chr, context$to_compare_determ
      )

      return(list(higher_than = relat$higher_than_num,
                  text = sprintf("%s, %s", first_step, second_step)))

    })

    # Is the rank similar or different
    percs <- sapply(compare_texts, `[[`, "higher_than")
    percs_distance <- abs(percs[[1]] - percs[[2]])
    connector <- if (percs_distance > 0.2) "Whereas" else "Similarly"

    compare_texts$var_left$text <- s_sentence(compare_texts$var_left$text)

    # Bind it all
    out <- sprintf("%s<p>%s. %s, %s.", out, compare_texts$var_left$text,
                   connector, compare_texts$var_right$text)

    return(append_date(out))
  }

  # Scales
  scales_dictionary <- get_from_globalenv("scales_dictionary")
  scale_vec <- is_scale_df(scales_dictionary$scale, df, vectorized = TRUE)
  scale_plur <- scales_dictionary$plur[scale_vec]

  # Correlation
  relation <- explore_text_bivar_correlation(vars, data, lang = lang)

  # If there is no correlation, the text is slightly different
  if (relation$no_correlation) {

    # Explanations
    left_exp <- var_get_info(vars$var_left, what = "explanation",
                             translate = TRUE, lang = lang)
    right_exp <- var_get_info(vars$var_right, what = "explanation",
                              translate = TRUE, lang = lang)

    out <- sprintf("%s, there is %s (%s) between %s and %s in %s.",
                   s_sentence(context$p_start), relation$relation_text, relation$corr,
                   left_exp, right_exp, scale_plur)

    return(append_date(out))

  }

  # Adjectives
  left_adj <- explore_text_bivar_adjective(var = vars$var_left,
                                           left = TRUE,
                                           lang = lang)
  right_adj <- explore_text_bivar_adjective(var = vars$var_right,
                                            left = FALSE,
                                            positive = relation$positive,
                                            lang = lang)

  # Explanations
  left_exp <- var_get_info(vars$var_left, what = "explanation_nodet",
                           translate = TRUE, lang = lang)
  right_exp <- var_get_info(vars$var_right, what = "explanation_nodet",
                            translate = TRUE, lang = lang)

  # Paragraphs
  first_p <-
    if (grepl("_X_", relation$relation_text)) {
      # When the relationship is 'weak', it's a two-part relation_text
      relation_right_ajd_exp <-
        gsub("_X_", sprintf("have %s %s", right_adj, right_exp),
             relation$relation_text)

      sprintf("%s, %s with %s %s %s.",
              s_sentence(context$p_start), scale_plur, left_adj, left_exp,
              relation_right_ajd_exp)
    } else {

      sprintf("%s, %s with %s %s %s have %s %s.",
              s_sentence(context$p_start), scale_plur, left_adj, left_exp,
              relation$relation_text, right_adj, right_exp)
    }
  second_p <- sprintf("There is a %s (%s) between these two variables.",
                      relation$corr_strength, relation$corr)

  # Bind the two paragraphs
  out <- sprintf("<p>%s<p>%s", first_p, second_p)

  # Write STRONG CORRELATION if it is the case
  if (relation$strong) {
    out <- sprintf("<p><b>STRONG CORRELATION</b>%s", out)
  }

  return(append_date(out))

}

#' Function for exploring bivariate correlation between two variables
#'
#' This function calculates bivariate correlation between two variables and
#' returns a list containing the correlation coefficient, a boolean indicating
#' whether the correlation is positive or negative, a text string describing the
#' strength and direction of the correlation, and a text string describing the
#' relationship between the variables.
#'
#' @param vars <`character`> A list containing the variable names for which the
#' text needs to be generated. Usually the output of \code{\link{vars_build}}.
#' @param data <`data.frame`> A data frame containing the variables and
#' observations to be compared. The output of \code{\link{data_get}}.
#' @param lang <`character`> A string indicating the language in which to
#' translates the variable. Defaults to NULL.
#'
#' @return A list containing the correlation coefficient, a boolean indicating
#' whether the correlation is positive or negative, a text string describing
#' the strength and direction of the correlation, and a text string describing
#' the relationship between the variables.
explore_text_bivar_correlation <- function(vars, data, lang = NULL) {

  # Get correlation and method string
  corr <- explore_text_bivar_correlation_helper(vars = vars,
                                                data = data,
                                                lang = lang)

  # Is the correlation positive
  positive <- corr$corr > 0
  positive_string <- if (positive) "positive" else "negative"

  # Correlation strings
  absolute <- abs(corr$corr)
  # Flag the correlation as NOT strong to start with.
  strong <- FALSE
  # Flag the correlation as inexistant to start with
  no_correlation <- FALSE

  if (absolute > 0.7) {

    relation_text <- cc_t("almost always", lang = lang)
    strength <- "strong"
    strong <- TRUE

    corr_strength <- sprintf("%s %s correlation", strength, positive_string)

  } else if (absolute > 0.3) {
    relation_text <- cc_t("tend to", lang = lang)
    strength <- "moderate"

    corr_strength <- sprintf("%s %s correlation", strength, positive_string)

  } else if (absolute > 0.1) {
    relation_text <- cc_t("often _X_, although with many exceptions",
                          lang = lang)
    strength <- "weak"

    corr_strength <- sprintf("%s %s correlation", strength, positive_string)

  } else {
    relation_text <- cc_t("effectively no relationship", lang = lang)
    strength <- "effectively no correlation"
    no_correlation <- TRUE

    corr_strength <- strength
  }

  return(list(corr = corr$corr_string,
              strong = strong,
              positive = positive,
              no_correlation = no_correlation,
              relation_text = relation_text,
              corr_strength = corr_strength))
}

#' Helper function for generating adjective to describe bivariate relationship
#' between text variables
#'
#' This function generates a text string containing an adjective to describe the
#' bivariate relationship between two variables based on whether the relationship
#' is positive or negative.
#'
#' @param var <`character`> The variable code for which the text needs to be
#' generated. `vars$var_left` or `vars$var_right`
#' @param left <`logical>` Whether the `var` supplied is the var_left
#' or the `var_right`. If `var_left`, TRUE.
#' @param positive <`logical`> Wheter the bivariate relationship is positive
#' or negative. One of the output of \code{\link{explore_text_bivar_correlation}}
#' @param lang <`character`> A string indicating the language in which to
#' translates the variable. Defaults to NULL.
#' @param ... Additional arguments to be passed.
#'
#' @return A text string containing an adjective to describe the bivariate
#' relationship.
#' @export
explore_text_bivar_adjective <- function(var, left, positive, lang = NULL, ...) {
  UseMethod("explore_text_bivar_adjective", var)
}

#' @rdname explore_text_bivar_adjective
#' @export
explore_text_bivar_adjective.dollar <- function(var, left, positive, lang,
                                                ...) {
  if (left) return(cc_t("higher", lang = lang))
  if (positive) return(cc_t("higher", lang = lang))
  return(cc_t("lower", lang = lang))
}

#' @rdname explore_text_bivar_adjective
#' @export
explore_text_bivar_adjective.default <- function(var, left, positive, lang,
                                                 ...) {
  if (left) return(cc_t("a higher", lang = lang))
  if (positive) return(cc_t("a higher", lang = lang))
  return(cc_t("a lower", lang = lang))
}


# DELTA -------------------------------------------------------------------

#' @rdname explore_text
#' @export
explore_text.delta <- function(vars, region, select_id, df, data,
                               scales_as_DA = c("building", "street"),
                               lang = NULL, ...) {

  # Detect if we should switch the scale for DAs in the case the `df` is part
  # of the `scales_as_DA` argument.
  switch_DA <- is_scale_df(scales_as_DA, df)

  # Adjust the selected ID in the case where the selection is not in `data`
  if (!switch_DA && !select_id %in% data$ID) select_id <- NA

  # Grab the shared info
  context <- explore_context(
    region = region, select_id = select_id, df = df,
    switch_DA = switch_DA
  )

  # The context might have used a scale in the `scales_as_DA` argument, and
  # the select_id needs to be switched to that of the dissemination area.
  if ("select_id" %in% names(context)) select_id <- context$select_id

  # Grab the explanation and region values
  exp_vals <- explore_text_delta_exp(var = vars$var_left, region = region,
                                     select_id = select_id, data  = data,
                                     df = df)

  # Calculate the variation change
  change <- (exp_vals$region_vals[1] - exp_vals$region_vals[2]) / exp_vals$region_vals[2]
  change_string <- convert_unit.pct(x = change, decimal = 1)

  # Did it increase or decrease
  inc_dec <- if (change > 0) "increased" else "decreased"

  # Craft the paragraphs
  first_part <- sprintf("%s, %s changed from %s in %s to %s in %s.",
                        s_sentence(context$p_start), exp_vals$exp,
                        exp_vals$region_vals_strings[2], exp_vals$times[1],
                        exp_vals$region_vals_strings[1], exp_vals$times[2])
  second_part <- sprintf("%s has %s by %s between these years.",
                         s_sentence(exp_vals$exp), inc_dec, change_string)

  # Bind
  out <- sprintf("<p>%s<p>%s", first_part, second_part)

  # Return the first paragraph if there are no selections
  if (is.na(select_id)) return(out)

  # Add the header for the selection
  out <- sprintf("<p><b>%s</b><p>%s", context$heading, out)

  # Get the necessary information for the second paragraph
  inc_dec <- if (change > 0) "increase" else "decrease"
  exp_nodet <- var_get_info(vars$var_left, what = "explanation_nodet")
  relat <- explore_text_selection_comparison(
    var = vars$var_left,
    data = data,
    select_id = select_id,
    col = "var_left",
    ranks_override = c("exceptionally small", "unusually small",
                       "just about average", "unusually large",
                       "exceptionnally large"))

  # Craft the second paragraph
  first_part <- sprintf("This %s is %s for %s.", inc_dec,
                        relat$rank_chr, context$to_compare_deter)
  second_part <-
    sprintf(paste0("The change in %s %s between %s and %s is larger than %s of ",
                   "other %s between the same years."),
            exp_nodet, context$p_start, exp_vals$times[1],
            exp_vals$times[2], relat$higher_than, context$scale_plur)

  out <- sprintf("%s<p>%s %s", out, first_part, second_part)

  # Return
  return(out)
}

#' Explore text `delta` explanation and values for
#'
#' This function delivers the delta text and values of a given variable when
#' compared between two yeas. It dispatches to specific methods depending on the
#' structure of the variable.
#'
#' @param var <`character`> The variable code for which the text and values need
#' to be generated. Usually `vars$var_left`.
#' @param region <`character`> Character string specifying the name of the region.
#' Usually equivalent of `r$region()`.
#' @param ... Additional arguments passed to the dispatched method.
#'
#' @return A list with the following elements:
#' \item{exp}{A character string describing the explanation of the variable}
#' \item{region_vals}{A numeric vector containing the variable values in the
#' current region and time period.}
#' \item{region_vals_strings}{A character vector with the same length as
#' \code{region_vals}, containing the variable values formatted according
#' to the class of `var`}
explore_text_delta_exp <- function(var, region, ...) {
  UseMethod("explore_text_delta_exp", var)
}

#' @rdname explore_text_delta_exp
#' @export
explore_text_delta_exp.ind <- function(var, region, select_id, ...) {

  # Grab the parent variable
  parent <- var_get_info(var = var[[1]], what = "parent_vec")

  # Grab the explanation
  exp_q5 <- var_get_info(var = var[[1]], what = "exp_q5")

  # Sub the placeholder for the two last brackets
  breaks <- var_get_info(var = var[[1]], what = "breaks_q5")[[1]]
  breaks <- breaks[grepl(paste0("^", region, "_"), breaks$df), ]
  two_last_ranks <- tolower(breaks$rank_name[breaks$rank > 3])[1:2]
  # If the two last brackets is recognized as the default, write a particular string
  exp <- if (identical(two_last_ranks, c("above average", "high"))) {
    gsub("_X_", "a higher-than-average", exp_q5)
  } else {
    gsub("_X_", sprintf(
      "`%s` to `%s`", two_last_ranks[[1]],
      two_last_ranks[[2]]
    ), exp_q5)
  }

  # Grab the region values
  times <- var_get_time(var)
  region_vals <- var_get_info(var[[1]], what = "region_values")[[1]]
  region_vals <- region_vals[region_vals$region == region, ]
  region_vals <- region_vals$val[region_vals$year %in% times]
  region_vals_strings <- convert_unit.pct(var, x = region_vals,
                                          decimal = 1)

  # Return
  return(list(exp = sprintf("the percentage of %s that %s", parent, exp),
              region_vals = region_vals,
              region_vals_strings = region_vals_strings,
              times = times))
}

#' @rdname explore_text_delta_exp
#' @export
explore_text_delta_exp.default <- function(var, region, select_id, data, df,
                                           ...) {

  # Grab the explanation
  exp <- var_get_info(var[[1]], what = "explanation")

  # Grab the region values
  times <- var_get_time(var)
  if (is.na(select_id)) {
    region_vals <- var_get_info(var[[1]], what = "region_values")[[1]]
    region_vals <- region_vals[region_vals$region == region, ]
    region_vals <- region_vals$val[region_vals$year %in% times]
  } else {
    # Grab the region values
    region_values <-
      lapply(var, \(x) explore_text_region_val_df(
        var = structure(x, class = class(var)),
        region = region,
        select_id = select_id,
        data = data,
        df = df,
        col = sprintf("var_left_%s", which(x == var))
      ))
    region_vals <- sapply(region_values, `[[`, "val")
    # Newest value must be first, like for the no-selection values
    region_vals <- rev(region_vals)
  }

  region_vals_strings <- convert_unit(var, x = region_vals, decimal = 1)

  # Return
  return(list(exp = exp,
              region_vals = region_vals,
              region_vals_strings = region_vals_strings,
              times = times))
}

# DELTA BIVAR -------------------------------------------------------------


